# Домашнее задание. Тесты

## О моем приложении и его текущем состоянии:
Приложение состоит из клиента на реакте и сервера на Node.js:
- Клиент лежит в папке 'client'. Клиент сделан на реакте и изменения состояний на странице сделаны через хуки useState. В каждом компоненте реализована логика запросов к серверу. Это неправильно, были замечания у проверяющего в дз по React. Все из-за того, что плохо разобралась с темой архитектура React'а, и далее уже не было времени исправлять. Рефакторинг клиента я оцениваю в 30 часов - разобраться с redux, прикрутить, отладить ошибки, доделать ту функциональность, которая сейчас не работает из-за плохой архитектуры. 
Например, на странице settings не знаю как отобразить текущие настройки в полях input, если они уже есть. Вроде бы можно получить с сервера данные, но не знаю как в текущей архитектуре их передать, и чтобы не было бесконечных циклов и чтобы вводимые пользователем данные не затирались теми, которые уже на сервере хранятся.
- Сервер - это по сути прокси между клиентом и базой данных, который еще может клонировать репозиторий и искать по нему некоторые данные. 

## какие сценарии вы проверяете интеграционными тестами? +обоснование
Интеграционные тесты написаны с помощью hermione. Проверяется работа клиента на реакте в связке с Node.js-сервером, все на реальной базе данных. 
Когда я начала писать тесты, то поняла, что в моей архитектуре невозможно даже написать заглушки (stub), потому что много монолитных функций. На клиенте я выделила запросы к серверу в controller.js, но не понимаю, как куда писать заглушку для тестов. Поэтому пункт с написанием заглушек - можно считать проваленным.

В итоге, нарисовалась следующая картина. Чтобы написать хорошие тесты, с заглушками, и не сломать ничего (а уже поломала и день чинила приложение, после рефакторинга с controller.js), нужно сначала переделать архитектуру. С этим большие проблемы (как писала см.выше) и 30 дополнительных часов уже нет. 
Чтобы показать, что мне удалось разобраться с написанием тестов на hermione, я решила написать тесты на какую-нибудь одну страницу, выбрала settings, так как в ней есть кнопки, поля для ввода данных, запросы к серверу. 
Сценарий:
1) при открытии страниц с настройками проверяется наличие различных элементов на ней
- header
- footer
- copyright
- input'ы
- и др
2) у пользователя уже указаны настройки. Он вводит новые настройки, нажимает Save, переходит на страницу с историей билдов, возвращается на страницу c настройками и видит измененные настройки. Здесь мы проверяем, что запрос отправился на сервер, был обработан, сохранен в БД. Этот тест падает, потому что не получилось брать настройки с сервера и записывать их в поле input (реакт не обновляет значения объекта settingsFromServer, файл Form.jsx).
3) пользователь вводит в поле настроек, поле build command невалидную и опасную команду rm -rf, ничего не должно выполняться. Должно появиться сообщение (alert) о неправильной билдовой команде. 


Тестовые сценарии, которые я бы написала, если бы сервер работал (но их нет):
1) пользователь заходит первый раз, у него нет настроек на сервере. Ожидается открытие стартовой страницы с приветствием.
2) пользователь ввел commit hash на странице с историей билдов, нажал Build. Коммит появился в списке билдов.
3) пользователь ввел commit hash на странице с историей билдов, нажал Build. После появления коммита на странице билдов кликаем на появившийся билд, должна открыться страница с билдом, дожидаемся появления лога билда.
4) пользователь вводит в поле настроек, поле build command невалидные и опасные команды, например, rm -rf, ничего не должно выполняться. 


## из каких логических блоков состоит ваше приложение и какие их сценарии вы проверяете модульными тестами? +обоснование
Архитектура очень плохая, поэтому тестировать трудно. 
- функции неатомарны, отвечают за множество разных действий. 
- запросы к API сервера и к API базы данных не вынесены в отдельные методы, есть нечто похожее на контроллер, но как будто бы он неправильно написан. Невозможно сделать stub без масштабного рефакторинга.
- отсутствует redux, поэтому в коде клиента нет разделения между логикой приложения и отображением. 
- сайд эффекты присутствуют в компонентах реакт приложения (useState вместо useEffect повсеместно), поэтому затруднительно написать модульные тесты на реакт без рефакторинга.

Во всем коде можно выделить несколько блоков, которые точно работают и которые можно покрыть модульными тестами:
- функция конвертации даты и времени в реакт приложении (клиент)
- функции-утилиты в server_utils (сервер)

Также, для выполнения вступительного задания в ШРИ, задача 2 (написание линтера), я разобралась с mocha, chai, прикрутила [генератор отчетов mochawesome](https://github.com/appalse/shri-2/tree/master/mochawesome-report), написала [действительно много разнообразных тестов](https://github.com/appalse/shri-2/tree/master/test) на линтер. То есть с этой темой, считаю, что разобралась хорошо еще при поступлении. Поэтому сейчас решила потратить время на исправление ошибок в сервере и другие домашки.


## как запустить тесты?

### Запуск интеграционных тестов
```
npm install
```
В отдельной консоли (запустить селениум-сервер, порт 4444):
```
selenium-standalone start
```
Еще в одной отдельной консоли (запустить node.js сервер моего приложения, порт 5000, нужно задать API_TOKEN в файле .env*, см.внизу):
```
node server/server
```
В третьей консоли (запустить клиент на реакте, порт 3000):
```
cd client
npm start
```
В другой консоли (запуск интеграционных тестов):
```
.\node_modules\.bin\hermione  .\tests\integration\settings.hermione.js
```

### Запуск модульных тестов
```
mocha .\tests\unit\
```

### Результаты

Результаты отобразятся в консоли. Иногда API базы данных возвращает какую-то дичь, которую я не обрабатываю на сервере, Из-за этого могут вылетать alert'ы в тестах, которые не отловлены тестами. Тогда надо запустить тест еще раз.

* Примечание:
Нужно создать файл .env в корневой директории (рядом с package.json) и задать свой токен* через:
```
API_TOKEN=sfsksuehfksjdfhisudhf...
```
Это специальный токен, который нужно передавать в заголовке Authorization (например, Authorization: Bearer eyjhbgcioijiuzi1niisi, где "eyjhbgcioijiuzi1niisi" — это токен). Получить токен можно на страничке https://hw.shri.yandex. Для этого нужно залогиниться через GitHub. Скопируйте токен и задавайте его в API_TOKEN в .env

Дополнительно:
в запросах к API укажите параметр "не проверять сертификат":
- curl — добавьте параметр -k или --insecure
- модули https и request — добавьте параметр rejectUnauthorized: false
